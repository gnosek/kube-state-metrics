package aggregation

import (
	"fmt"
	"io"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/kube-state-metrics/pkg/metric"
	"strconv"
	"strings"
)

// A metric value that will eventually be aggregated with others sharing the same LabelValues
// Since the aggregation function can return multiple sets of label values,
// a single Metric can correspond to multiple AggregatedValues.
// Technically we could store the value just once and make LabelValues a [][]string
// but keeping it this way makes the code simpler at minimal cost (a bunch of floats)
type AggregatedValue struct {
	Value       float64
	LabelValues []string
}

// An Aggregation supported by a metric family generated by a FamilyGenerator
// The Aggregate() function takes an object (same as passed to the generator's
// GenerateFunc()) and the metric family as returned by the GenerateFunc().
// It returns an array of AggregatedValues, each corresponding to a separate
// metric in the aggregated family
type Aggregation struct {
	LabelNames []string
	Aggregate  func(interface{}, metric.FamilyInterface) []AggregatedValue
}

// The runtime representation of an aggregated metric
type AggregatedMetric struct {
	// metric family metadata, generated once while creating the object
	Header     string
	Name       string
	MetricType metric.Type

	// AggregatedValues for each individual Kubernetes object
	Objects map[types.UID][]AggregatedValue

	// label names and the aggregation function come directly from the Aggregation object
	LabelNames      []string
	AggregationFunc func(interface{}, metric.FamilyInterface) []AggregatedValue
}

// AggregationSet represents all aggregations available from a single FamilyGenerator
type AggregationSet struct {
	aggregations map[string]*AggregatedMetric

	// Aggregations are calculated lazily: an update to the stored metrics
	// sets this flag to false and then the aggregates are recalculated
	// during WriteAll().
	// This means that aggregations are recalculated at most once per
	// HTTP request, but only if the underlying metric values changed
	// in the meantime
	cache map[string]metric.Family
}

// Generate a header for an aggregated metric family
// This is based on the original metric header but includes
// the aggregation labels in the help text
func generateAggregateHeader(name string, metricType metric.Type, help string, aggregationName string) string {
	header := strings.Builder{}
	header.WriteString("# HELP ")
	header.WriteString(name)
	header.WriteByte(' ')
	header.WriteString(strings.TrimSuffix(help, "."))
	header.WriteString(", aggregated by ")
	header.WriteString(aggregationName)
	header.WriteString(".\n# TYPE ")
	header.WriteString(name)
	header.WriteByte(' ')
	header.WriteString(string(metricType))

	return header.String()
}

// Generate a suffix for the aggregated metric family
// to be appended to the original family name, e.g.
// aggregating kube_foo by an aggregation named bar should
// yield a family called kube_foo_sum_by_bar
func AggregatedMetricNameSuffix(aggregationName string) string {
	return "_sum_by_" + aggregationName
}

// Create a new aggregated metric
func NewAggregatedMetric(familyName string, familyType metric.Type, familyHelp string, aggregationName string, aggregation Aggregation) AggregatedMetric {
	aggregatedMetricName := familyName + AggregatedMetricNameSuffix(aggregationName)

	return AggregatedMetric{
		Header:          generateAggregateHeader(aggregatedMetricName, familyType, familyHelp, aggregationName),
		Name:            aggregatedMetricName,
		MetricType:      familyType,
		LabelNames:      aggregation.LabelNames,
		Objects:         make(map[types.UID][]AggregatedValue),
		AggregationFunc: aggregation.Aggregate,
	}
}

// Add a new object to the AggregatedMetric
// We immediately call the aggregation function and store its results
func (a *AggregatedMetric) Add(obj metav1.Object, family metric.FamilyInterface) {
	var objects []AggregatedValue
	family.Inspect(func(f metric.Family) {
		objects = append(objects, a.AggregationFunc(obj, f)...)
	})
	a.Objects[obj.GetUID()] = objects
}

// Delete an object (by uid) from the set of values to be aggregated
func (a *AggregatedMetric) Delete(uid types.UID) {
	delete(a.Objects, uid)
}

// Delete all objects from the aggregation
func (a *AggregatedMetric) Clear() {
	a.Objects = make(map[types.UID][]AggregatedValue)
}

// Get the result of the aggregation as a metric family
func (a *AggregatedMetric) GetMetricFamily(shard int) metric.Family {
	aggValue := make(map[string]float64)
	labelValueSets := make(map[string][]string)
	for _, obj := range a.Objects {
		for _, m := range obj {
			labelString := fmt.Sprintf("%#v", m.LabelValues)
			labelValueSets[labelString] = m.LabelValues

			// this is what makes all the aggregations sums
			aggValue[labelString] += m.Value
		}
	}

	var metrics []*metric.Metric
	for tag, labelValues := range labelValueSets {
		metrics = append(metrics, &metric.Metric{
			LabelKeys:   append(a.LabelNames, "shard"),
			LabelValues: append(labelValues, strconv.Itoa(shard)),
			Value:       aggValue[tag],
		})
	}

	return metric.Family{
		Name:    a.Name,
		Type:    a.MetricType,
		Metrics: metrics,
	}
}

// Build an AggregationSet out of a map of Aggregations
func NewAggregationSet(aggregations map[string]Aggregation, name string, help string, familyType metric.Type) *AggregationSet {
	if len(aggregations) == 0 {
		return nil
	}

	set := make(map[string]*AggregatedMetric)
	for aggName, agg := range aggregations {
		a := NewAggregatedMetric(name, familyType, help, aggName, agg)
		set[aggName] = &a
	}

	as := AggregationSet{
		aggregations: set,
		cache:        nil,
	}
	return &as
}

func (as *AggregationSet) Add(obj interface{}, family metric.FamilyInterface) {
	for _, am := range as.aggregations {
		am.Add(obj.(metav1.Object), family)
	}

	as.cache = nil
}

func (as *AggregationSet) Delete(uid types.UID) {
	for _, am := range as.aggregations {
		am.Delete(uid)
	}

	as.cache = nil
}

func (as *AggregationSet) Clear() {
	for _, am := range as.aggregations {
		am.Clear()
	}

	as.cache = nil
}

func (as *AggregationSet) getMetricFamilies(shard int) map[string]metric.Family {
	aggregated := make(map[string]metric.Family)
	for name, am := range as.aggregations {
		aggregated[name] = am.GetMetricFamily(shard)
	}

	return aggregated
}

func (as *AggregationSet) WriteAll(w io.Writer, shard int) error {
	// Have there been any state updates since the last request?
	if as.cache == nil {
		// yes, recalculate aggregations
		as.cache = as.getMetricFamilies(shard)
	}

	for name, family := range as.cache {
		if _, err := io.WriteString(w, as.aggregations[name].Header); err != nil {
			return err
		}
		if _, err := w.Write([]byte{'\n'}); err != nil {
			return err
		}
		if _, err := w.Write(family.ByteSlice()); err != nil {
			return err
		}
	}

	return nil
}
